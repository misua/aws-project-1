{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Set up Terraform Project Structure",
        "description": "Initialize the Terraform project with proper directory structure, provider configuration, and variables.",
        "details": "Create the following directory structure:\n```\n./\n├── main.tf\n├── variables.tf\n├── outputs.tf\n├── terraform.tfvars\n├── modules/\n│   ├── vpc/\n│   ├── ec2/\n│   ├── s3/\n│   └── iam/\n└── scripts/\n```\n\nIn main.tf, configure the AWS provider with region parameter. In variables.tf, define variables for:\n- AWS region\n- VPC CIDR block\n- Public and private subnet CIDR blocks\n- EC2 instance types (ensure t2.micro for Free Tier)\n- Your home IP for SSH access\n- Path to your id_ed25519.pub key\n\nInitialize the project with `terraform init`.",
        "testStrategy": "Verify the project structure is correct and that `terraform init` completes successfully without errors. Validate the configuration with `terraform validate`.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement VPC and Network Infrastructure",
        "description": "Create a VPC with public and private subnets, route tables, and Internet Gateway using Terraform.",
        "details": "In the vpc module, create:\n1. VPC with specified CIDR block\n2. Public subnet in one availability zone\n3. Private subnet in the same availability zone\n4. Internet Gateway attached to the VPC\n5. Route tables for both subnets\n6. Associate route tables with respective subnets\n7. Add route to Internet Gateway in the public subnet route table\n\nExample code:\n```hcl\nresource \"aws_vpc\" \"main\" {\n  cidr_block = var.vpc_cidr\n  enable_dns_support = true\n  enable_dns_hostnames = true\n  tags = {\n    Name = \"${var.project_name}-vpc\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  vpc_id = aws_vpc.main.id\n  cidr_block = var.public_subnet_cidr\n  availability_zone = \"${var.aws_region}a\"\n  map_public_ip_on_launch = true\n  tags = {\n    Name = \"${var.project_name}-public-subnet\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  vpc_id = aws_vpc.main.id\n  cidr_block = var.private_subnet_cidr\n  availability_zone = \"${var.aws_region}a\"\n  tags = {\n    Name = \"${var.project_name}-private-subnet\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"igw\" {\n  vpc_id = aws_vpc.main.id\n  tags = {\n    Name = \"${var.project_name}-igw\"\n  }\n}\n\n# Create route tables and associations\n```",
        "testStrategy": "Run `terraform plan` to verify the VPC resources are correctly configured. Check that the CIDR blocks don't overlap and that the route tables have the correct routes defined.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement NAT Instance for Private Subnet",
        "description": "Create a NAT instance (t2.micro) in the public subnet to allow outbound internet access from the private subnet.",
        "details": "1. Create a security group for the NAT instance allowing inbound traffic from the private subnet and outbound traffic to the internet\n2. Launch an Amazon Linux 2 t2.micro instance with NAT AMI in the public subnet\n3. Enable source/destination check = false on the instance\n4. Add a route in the private subnet route table pointing to the NAT instance for internet access\n\n```hcl\n# Security group for NAT instance\nresource \"aws_security_group\" \"nat_sg\" {\n  name        = \"${var.project_name}-nat-sg\"\n  description = \"Security group for NAT instance\"\n  vpc_id      = aws_vpc.main.id\n\n  ingress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [var.private_subnet_cidr]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# NAT instance\ndata \"aws_ami\" \"amazon_linux_2\" {\n  most_recent = true\n  owners      = [\"amazon\"]\n  filter {\n    name   = \"name\"\n    values = [\"amzn2-ami-hvm-*-x86_64-gp2\"]\n  }\n}\n\nresource \"aws_instance\" \"nat\" {\n  ami                    = data.aws_ami.amazon_linux_2.id\n  instance_type          = \"t2.micro\"\n  subnet_id              = aws_subnet.public.id\n  vpc_security_group_ids = [aws_security_group.nat_sg.id]\n  source_dest_check      = false\n  user_data              = <<-EOF\n                            #!/bin/bash\n                            sysctl -w net.ipv4.ip_forward=1\n                            /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\n                            EOF\n  tags = {\n    Name = \"${var.project_name}-nat-instance\"\n  }\n}\n\n# Add route to private subnet route table\nresource \"aws_route\" \"private_nat_route\" {\n  route_table_id         = aws_route_table.private.id\n  destination_cidr_block = \"0.0.0.0/0\"\n  instance_id            = aws_instance.nat.id\n}\n```",
        "testStrategy": "Verify the NAT instance is running in the public subnet and that the private subnet route table has a route to the NAT instance. Test connectivity from the private subnet to the internet by SSHing into an instance in the private subnet and attempting to download a package.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create Bastion Host in Public Subnet",
        "description": "Provision an EC2 bastion host in the public subnet with SSH access from your home IP.",
        "details": "1. Create a security group for the bastion host allowing SSH access only from your home IP\n2. Launch an Amazon Linux 2 t2.micro instance in the public subnet\n3. Configure the instance with your SSH public key (id_ed25519.pub)\n\n```hcl\n# Security group for bastion host\nresource \"aws_security_group\" \"bastion_sg\" {\n  name        = \"${var.project_name}-bastion-sg\"\n  description = \"Security group for bastion host\"\n  vpc_id      = aws_vpc.main.id\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"${var.home_ip}/32\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# Bastion host\nresource \"aws_instance\" \"bastion\" {\n  ami                    = data.aws_ami.amazon_linux_2.id\n  instance_type          = \"t2.micro\"\n  subnet_id              = aws_subnet.public.id\n  vpc_security_group_ids = [aws_security_group.bastion_sg.id]\n  key_name               = aws_key_pair.ssh_key.key_name\n\n  tags = {\n    Name = \"${var.project_name}-bastion\"\n  }\n}\n\n# SSH key pair\nresource \"aws_key_pair\" \"ssh_key\" {\n  key_name   = \"${var.project_name}-key\"\n  public_key = file(var.ssh_public_key_path)\n}\n```",
        "testStrategy": "Verify the bastion host is running and accessible via SSH from your home IP. Test with: `ssh -i ~/.ssh/id_ed25519 ec2-user@<bastion-public-ip>`",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create IAM Role for EC2 with S3 Access",
        "description": "Create an IAM role and instance profile that grants the app EC2 instance access to S3.",
        "details": "1. Create an IAM policy that allows read/write access to the S3 bucket\n2. Create an IAM role that can be assumed by EC2 instances\n3. Attach the policy to the role\n4. Create an instance profile and associate it with the role\n\n```hcl\n# IAM policy for S3 access\nresource \"aws_iam_policy\" \"s3_access\" {\n  name        = \"${var.project_name}-s3-access\"\n  description = \"Allow EC2 instance to access S3 bucket\"\n  policy      = jsonencode({\n    Version = \"2012-10-17\",\n    Statement = [\n      {\n        Effect = \"Allow\",\n        Action = [\n          \"s3:GetObject\",\n          \"s3:PutObject\",\n          \"s3:ListBucket\",\n          \"s3:DeleteObject\"\n        ],\n        Resource = [\n          \"arn:aws:s3:::${var.bucket_name}\",\n          \"arn:aws:s3:::${var.bucket_name}/*\"\n        ]\n      }\n    ]\n  })\n}\n\n# IAM role for EC2\nresource \"aws_iam_role\" \"ec2_role\" {\n  name = \"${var.project_name}-ec2-role\"\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\",\n    Statement = [\n      {\n        Effect = \"Allow\",\n        Principal = {\n          Service = \"ec2.amazonaws.com\"\n        },\n        Action = \"sts:AssumeRole\"\n      }\n    ]\n  })\n}\n\n# Attach policy to role\nresource \"aws_iam_role_policy_attachment\" \"s3_access_attachment\" {\n  role       = aws_iam_role.ec2_role.name\n  policy_arn = aws_iam_policy.s3_access.arn\n}\n\n# Instance profile\nresource \"aws_iam_instance_profile\" \"ec2_profile\" {\n  name = \"${var.project_name}-ec2-profile\"\n  role = aws_iam_role.ec2_role.name\n}\n```",
        "testStrategy": "Verify the IAM role, policy, and instance profile are created correctly. Check that the policy grants the necessary permissions to access the S3 bucket.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create S3 Bucket for Log Storage",
        "description": "Provision an S3 bucket with versioning enabled and public access blocked for storing logs.",
        "details": "1. Create an S3 bucket with a unique name\n2. Enable versioning on the bucket\n3. Block all public access to the bucket\n4. Configure server-side encryption\n\n```hcl\nresource \"aws_s3_bucket\" \"logs\" {\n  bucket = var.bucket_name\n  tags = {\n    Name = \"${var.project_name}-logs\"\n  }\n}\n\nresource \"aws_s3_bucket_versioning\" \"logs_versioning\" {\n  bucket = aws_s3_bucket.logs.id\n  versioning_configuration {\n    status = \"Enabled\"\n  }\n}\n\nresource \"aws_s3_bucket_public_access_block\" \"logs_public_access\" {\n  bucket = aws_s3_bucket.logs.id\n\n  block_public_acls       = true\n  block_public_policy     = true\n  ignore_public_acls      = true\n  restrict_public_buckets = true\n}\n\nresource \"aws_s3_bucket_server_side_encryption_configuration\" \"logs_encryption\" {\n  bucket = aws_s3_bucket.logs.id\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm = \"AES256\"\n    }\n  }\n}\n```",
        "testStrategy": "Verify the S3 bucket is created with versioning enabled and public access blocked. Attempt to access the bucket publicly to confirm it's not accessible.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create App EC2 Instance in Private Subnet",
        "description": "Provision an EC2 instance in the private subnet with Docker installed and configured to run the web application.",
        "details": "1. Create a security group for the app instance allowing SSH from the bastion host and HTTP access from within the VPC\n2. Launch an Amazon Linux 2 t2.micro instance in the private subnet\n3. Attach the IAM instance profile created in Task 5\n4. Configure the instance with your SSH public key\n5. Create a user data script to install Docker and set it to start on boot\n\n```hcl\n# Security group for app instance\nresource \"aws_security_group\" \"app_sg\" {\n  name        = \"${var.project_name}-app-sg\"\n  description = \"Security group for app instance\"\n  vpc_id      = aws_vpc.main.id\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    security_groups = [aws_security_group.bastion_sg.id]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \"tcp\"\n    cidr_blocks = [var.vpc_cidr]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n\n# App instance\nresource \"aws_instance\" \"app\" {\n  ami                    = data.aws_ami.amazon_linux_2.id\n  instance_type          = \"t2.micro\"\n  subnet_id              = aws_subnet.private.id\n  vpc_security_group_ids = [aws_security_group.app_sg.id]\n  key_name               = aws_key_pair.ssh_key.key_name\n  iam_instance_profile   = aws_iam_instance_profile.ec2_profile.name\n\n  user_data = <<-EOF\n              #!/bin/bash\n              yum update -y\n              amazon-linux-extras install docker -y\n              systemctl enable docker\n              systemctl start docker\n              usermod -a -G docker ec2-user\n              # Create a script to pull and run the Docker container on boot\n              cat > /usr/local/bin/start-app.sh << 'SCRIPT'\n              #!/bin/bash\n              docker pull nginxdemos/hello\n              docker run -d -p 80:80 --restart always nginxdemos/hello\n              SCRIPT\n              chmod +x /usr/local/bin/start-app.sh\n              # Add to crontab to run on reboot\n              echo \"@reboot /usr/local/bin/start-app.sh\" | crontab -\n              # Run it now\n              /usr/local/bin/start-app.sh\n              EOF\n\n  tags = {\n    Name = \"${var.project_name}-app\"\n  }\n}\n```",
        "testStrategy": "Verify the app instance is running in the private subnet. SSH into the bastion host and then into the app instance to check that Docker is installed and running. Verify the Docker container starts automatically on reboot.",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Docker Web Application",
        "description": "Create or select a Docker image for a simple web application that will run on the EC2 instance.",
        "details": "For simplicity, we'll use the existing nginxdemos/hello image, but if you want to create a custom app, here's how:\n\n1. Create a directory for your app\n2. For a simple Flask app, create app.py:\n```python\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    return '<h1>Hello, World!</h1>'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=80)\n```\n\n3. Create requirements.txt:\n```\nflask==2.0.1\n```\n\n4. Create Dockerfile:\n```dockerfile\nFROM python:3.9-slim\nWORKDIR /app\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\nCOPY app.py .\nEXPOSE 80\nCMD [\"python\", \"app.py\"]\n```\n\n5. Build and push the image to Docker Hub (optional):\n```bash\ndocker build -t yourusername/hello-app .\ndocker push yourusername/hello-app\n```\n\nIf using the existing nginxdemos/hello image, update the user_data script in the app EC2 instance to pull and run this image.",
        "testStrategy": "Build and run the Docker image locally to verify it works correctly. If using a custom image, push it to Docker Hub and verify it can be pulled.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Configure Terraform Outputs",
        "description": "Define Terraform outputs for the bastion public IP, S3 bucket name, and app EC2 private IP.",
        "details": "In outputs.tf, define the following outputs:\n\n```hcl\noutput \"bastion_public_ip\" {\n  description = \"Public IP address of the bastion host\"\n  value       = aws_instance.bastion.public_ip\n}\n\noutput \"app_private_ip\" {\n  description = \"Private IP address of the app instance\"\n  value       = aws_instance.app.private_ip\n}\n\noutput \"s3_bucket_name\" {\n  description = \"Name of the S3 bucket for logs\"\n  value       = aws_s3_bucket.logs.bucket\n}\n\noutput \"ssh_tunnel_command\" {\n  description = \"Command to create SSH tunnel to access the app via the bastion\"\n  value       = \"ssh -i ~/.ssh/id_ed25519 -L 8080:${aws_instance.app.private_ip}:80 ec2-user@${aws_instance.bastion.public_ip}\"\n}\n```",
        "testStrategy": "Run `terraform apply` and verify that the outputs are displayed correctly. Test the SSH tunnel command to ensure it works.",
        "priority": "low",
        "dependencies": [
          4,
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create Documentation and Test Script",
        "description": "Create a comprehensive README.md with architecture diagram, deployment instructions, and a test script to verify the infrastructure.",
        "details": "1. Create a README.md file with the following sections:\n   - Project Overview\n   - Architecture Diagram (ASCII or image)\n   - Prerequisites\n   - Deployment Instructions\n   - SSH Tunnel Instructions\n   - Design and Security Decisions\n   - Free Tier Usage Notes\n   - Cleanup Instructions\n\n2. Create a test script (test.sh) that verifies:\n   - VPC and subnet creation\n   - Bastion host accessibility\n   - App instance running Docker\n   - Web app accessibility via SSH tunnel\n   - S3 bucket accessibility from the app instance\n\n```bash\n#!/bin/bash\n# test.sh\nset -e\n\n# Get outputs from Terraform\nBASH_PUBLIC_IP=$(terraform output -raw bastion_public_ip)\nAPP_PRIVATE_IP=$(terraform output -raw app_private_ip)\nS3_BUCKET=$(terraform output -raw s3_bucket_name)\n\necho \"Testing SSH access to bastion host...\"\nssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no ec2-user@$BASH_PUBLIC_IP \"echo 'Bastion host is accessible'\"\n\necho \"Testing SSH access to app instance...\"\nssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no -J ec2-user@$BASH_PUBLIC_IP ec2-user@$APP_PRIVATE_IP \"echo 'App instance is accessible'\"\n\necho \"Checking Docker installation on app instance...\"\nssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no -J ec2-user@$BASH_PUBLIC_IP ec2-user@$APP_PRIVATE_IP \"docker --version && docker ps\"\n\necho \"Testing S3 bucket access from app instance...\"\nssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no -J ec2-user@$BASH_PUBLIC_IP ec2-user@$APP_PRIVATE_IP \"aws s3 ls s3://$S3_BUCKET\"\n\necho \"Testing web app accessibility...\"\necho \"Starting SSH tunnel in background...\"\nssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no -fN -L 8080:$APP_PRIVATE_IP:80 ec2-user@$BASH_PUBLIC_IP\necho \"Waiting for tunnel to establish...\"\nsleep 5\necho \"Testing HTTP connection to web app...\"\ncurl -s http://localhost:8080 | grep -q \"Hello\"\nif [ $? -eq 0 ]; then\n  echo \"Web app is accessible!\"\nelse\n  echo \"Failed to access web app\"\n  exit 1\nfi\n\n# Kill the SSH tunnel\npkill -f \"ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no -fN -L 8080:$APP_PRIVATE_IP:80\"\n\necho \"All tests passed!\"\n```",
        "testStrategy": "Run the test script after deployment to verify all components are working correctly. Check that the README.md contains all required information and is clear and comprehensive.",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4,
          6,
          7,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-22T06:29:11.601Z",
      "updated": "2025-07-22T07:14:02.225Z",
      "description": "Tasks for master context"
    }
  }
}